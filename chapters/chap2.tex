\chapter{相关工作}
本章将对本文的研究框架中所涉及的相关技术进行分析，主要分为三个方面：一个是详细分析图表征算法的相关技术及其发展演化，第二是对属性网络中相关的图表征算法进行介绍和分析，第三是对增量学习相关的技术细节进行分析。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%------------------------------------     函数与库推荐     -------------------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{图表征算法 }
图表征（Network Embedding/Representation）过程是通过一定算法获得网络中所有节点向量表征的一个过程，这类算法本身类似于一个完整任务的中间流程，因为没有对应的量化指标去直接衡量图表征算法是否性能突出，图表征算法从某些程度类似于高维数据的降维过程，降维之后需要放入特定的机器学习任务，如节点分类、节点聚类（社区发现）、节点相似度计算、链路预测等，通过学习任务的指标来衡量图表征过程的优良。尽管如此，一个好的图表征算法需要考虑的几点：

1. 对网络性质的保留：有效合理的图表征向量需要能够保留下网络本身的结构特征，比如节点间因为连接而产生的相似度，在向量化表征之后可以得到近似的结果。在这一方面存在的难题是，网络本身的性质存在很多，比如相似度、距离，这些性质在表征向量中不一定能完全兼顾，因此对于不同的图表征算法，其性能好坏取决于后续的具体应用。
2.伸缩性：现实应用中的网络规模非常巨大，节点至少都是千万级别的，节点间的连边的量级更是十亿级别的，所以图表征算法的可扩展性是非常具有现实意义的，但是当需要设计一个能保留网络全局信息的图表征算法的时候，设计一个伸缩性性好的算法是非常具有挑战性的。
3.表征向量的维数：对于表征向量来说，挑选一个合适的向量维度是比较困难的。高维向量会保留更多的网络原本的信息，从直观上理解，就相当于减小了舍入误差，但是过高维的向量表征对于学习任务来说其复杂度是不友好的；低维向量表征虽然能优化计算复杂度，但是过低维的向量表征会丢失一部分精度。对于向量表征的维度也是根据学习任务的不同特点来调整的。




%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%---------------------------------     相似移动应用检测     ----------------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{相似移动应用检测}
随着恶意移动应用的大量流行，给移动平台安全带来了巨大的挑战，特别是对使用量最多的Android平台\cite{huang2014asdroid}。因此亟需有效检测恶意移动应用的解决方法，而相似移动应用检测方法便是其中之一。相似移动应用通常是指，两个不同的移动应用具有类似的功能、界面、操作方式等。因此，相似移动应用表征了不同移动应用在功能上的相似性。在本文提出的第三方库推荐算法中，利用了移动应用间的相似关系，进而从相似移动应用中搜寻符合开发者需求的第三方库。检测相似移动应用在本文研究问题中尤为重要，因此本章将对已有的相似移动应用检测的研究工作做相关调研，并与本文提出的方法做比较和讨论。现有的检测相似移动应用的研究工作主要分为两种类别：动态检测和静态检测。因而，下文将分别从这两个类别对相似移动应用检测的相关工作进行阐述。

\subsection{动态检测}
动态检测方法通常是在移动应用运行过程中，监测代码执行、变量值等，该方法被广泛应用于检测相似移动应用。Myles等\cite{myles2004detecting}根据程序执行过程，构建一个完整的程序控制流图，从而识别相似的程序代码。Jhi等\cite{jhi2011value}利用某些关键运行变量无法被替换或删除这一特性，提出了一种识别可执行程序的动态检测方法。该文献中提出的代码检测方法，不受多种控制和数据混淆操作的影响。作者利用提取的不变量来构建不变量序列，进而使用最长公共子序列方法来计算序列间相似性，该相似性便用以衡量程序间的相似程度。如果不同的应用程序继承了包含语义明确的API调用函数，且这些API调用函数的功能需求相同，则说明应用程序具有高层的功能相似性。基于这一事实，McMillan等\cite{mcmillan2012detecting}提出了基于API调用函数的相似性算法。以上的相似软件检测方法大多面向传统应用软件（如Java、C++等），虽然可以通过一定的调整，应用于移动应用间的相似性检测，但是正如Crussell等\cite{crussell2012attack}在其论文中提出的，由于移动应用需要大量的交互操作，对于移动应用市场上大量的移动应用而言，若使用动态检测的方法，其可扩展性将大大受限，这将是一个巨大的挑战。因此，本文未使用动态检测的方法对移动应用相似性进行计算。下节将详细介绍静态检测在相似移动应用检测中的能力和问题。


\subsection{静态检测}
静态检测方法通常是通过分析移动应用的元数据、源代码等，来计算不同移动应用间的相似性。移动应用的元数据包括多种类别的数据，可以从统计分析、自然语言处理等角度进行分析和利用。移动应用的源代码则表征了其在程序编写中的功能特征，即包含了移动应用内部的特征信息。下文将详细阐述利用各类数据进行相似移动应用检测的方法。

Chen等\cite{chen2015simapp}从Google Play市场上爬取了移动应用元数据，包括移动应用名字、所属类别、开发者、描述、更新情况、权限、图片、评分、程序包大小、用户评论这十类数据，并分别对这十类元数据使用核函数计算相似性。核函数是机器学习中，将低维空间映射到高维空间的重要映射函数。作者利用核函数的特点，将移动应用间的相似性表示为十类元数据的核函数的线性组合，如下公式所示：
\begin{equation}
K(a_i, a_j; \mathbf{w}) = \sum_{k=1}^{n} w_k K^k (a_i, a_j)
\end{equation}
其中，$a_i$和$a_j$表示第$i$和第$j$个移动应用，$K(a_i, a_j; \mathbf{w})$表示目标移动应用的相似性函数，$K^k$代表第$k$类元数据的核函数，$n$为核函数的数量，$\mathbf{w} \in \mathbb{R}^n$为权重向量，其每一维元素$w_k$表示第$k$个核函数在相似性函数中所占的权重。在此相似性函数基础上，作者提出了在线核函数权重学习算法，利用随机梯度下降\cite{spall2005introduction}的方法来求解不同元数据的核函数的权重。Bhandari等\cite{bhandari2013serendipitous}同样利用了移动应用的元数据，并将移动应用的名字、描述和用户评论构建成一个移动应用文档。在此基础上，作者使用TF-IDF\cite{sparck1972statistical}算法将移动应用表示为一个特征向量，具体公式如下所示：
\begin{equation}
\mathbf{f}^a = (w_{t_1}^a, w_{t_2}^a, ..., w_{t_k}^a, ..., w_{t_m}^a)
\end{equation}
\begin{equation}
w_{t_k}^a = \frac{tf(t_k, a)}{\sum_{s=1}^{m} tf(t_s, a)} \cdot \log \frac{N_a}{df(t_k)}
\end{equation}
其中，$\mathbf{f}^a$代表移动应用$a$的特征向量，$w_{t_k}^a$为其中一维特征。对每维特征进行计算时，$tf(t_k, a)$表示移动应用$a$中出现词语$t_k$的频率，$N_a$表示所有移动应用的数量，$df(t_k)$则表示在移动应用文档中出现词语$t_k$的相应移动应用的数量。作者利用不同特征向量间的余弦值来表示移动应用间的相似性。褚征等\cite{chu2017construction}同样利用了元数据作为移动应用特征，并使用LDA模型\cite{blei2003latent}构建移动应用的相似度矩阵。以上文献均以元数据作为数据源，来抽取特征以表征移动应用功能信息，此类方法能够获得元数据中所包含的相关信息，但忽略了移动应用程序包本身所包含的功能信息，无法从程序代码层面获得相关特征。因此，此类方法提取的移动应用特征不够全面。本文提出的相似性计算方法分别从文本和视图两个层面对移动应用进行分析，从而能够更为全面地提取移动应用的特征，计算所得的相似性亦更具可靠性。

描述是移动应用市场上对移动应用功能进行阐述的文字，包含了移动应用的功能、特点等信息，被广泛用于移动应用的研究。Yin等\cite{yin2013app}将移动应用的描述当作文档，利用LDA模型\cite{blei2003latent}来抽取文档中的隐含主题，不同移动应用的隐含主题向量间的相似性表征了移动应用的功能重叠情况。作者用以下公式来计算功能重叠量：
\begin{equation}
w_{ij} = \frac{\mathbf{f}_i \cdot \mathbf{f}_j}{||\mathbf{f}_i|| \times ||\mathbf{f}_j||}
\end{equation}
其中，$\mathbf{f}_i$表示移动应用$i$的隐含主题分布向量，$(\cdot)$表示向量点乘操作，$||\mathbf{f}_i||$为向量$\mathbf{f}_i$的维度量。在本文的研究中，同样对移动应用的描述进行了分析和特征提取。而不同于Yin等\cite{yin2013app}对描述的处理，本文首先将描述中的非英文字符去除，其次又将不含实际意义的停顿词删去，最后对描述文本中的单词进行词根提取。本文处理后的描述文本包含更少的单词，能够更易学习获得文本特征。而且本文使用doc2vec模型\cite{le2014distributed}提取本文特征。不同于LDA的基于本文中隐含某些主题的假设，doc2vec将重点放在文本整体的语义分析上，通过学习单词间、单词在句中等的语义关系来构建特征，能够更好地对移动应用描述本文进行表征，详细内容将在本文4.3节中阐述。

除移动应用元数据外，其程序包中的程序代码同样包含了移动应用的功能信息，且更为细粒度，使用程序分析所提取的特征能够表征移动应用间更底层的相似性。对移动应用程度代码的分析主要从系统函数调用、程序控制流图、函数依赖图\cite{cheng2014class}等角度开展，通过比较不同移动应用间的函数、程序流图等相似程度，从而检测相似移动应用。王浩宇等\cite{wang2014detecting}统计了移动应用中每个变量在不同的代码片段中出现的次数，为移动应用构建了变量统计矩阵，矩阵中的每一行代表变量的特征向量，每一列代表对应变量在不同代码片段中出现的频数。在此基础上，作者使用余弦相似度来计算移动应用特征向量间的相似情况。AnDarwin\cite{crussell2015andarwin}使用WALA\cite{wala}为移动应用中的每个函数构建数据依赖图，并将其中相连的节点表示为语义块，每个语义块都由一个语义向量来表示。为避免对移动应用进行两两比较，AnDarwin利用局部敏感哈希（LSH: Locality Sensitive Hashing）\cite{andoni2006near}算法将语义向量进行聚类，并以此标记移动应用中的语义块，从而将每个移动应用表示为语义块的特征集合。对特征集合间的相似性计算，用以下公式实现：
\begin{equation}
J(A, B) = \frac{|F_A \cap F_B|}{|F_A \cup F_B|}
\end{equation}
其中，$F_A$和$F_B$分别表示移动应用$A$和移动应用$B$的特征集合。
与AnDarwin类似，DNADroid\cite{crussell2012attack}同样利用了程序依赖图来构建移动应用的特征集合，但DNADroid将特征集合中少于10个节点的程序依赖图过滤掉，从而减少非功能性的匹配。对移动应用$A$中的每个函数$f$，$m(f)$表示移动应用$B$的程序依赖图与移动应用$A$的程序依赖图最匹配的节点，DNADroid计算移动应用间的相似性用以下公式表示：
\begin{equation}
sim_{A(B)} = \frac{\sum_{f \in A} |m(f)|}{\sum_{f \in A} |f|}
\end{equation}
其中，$|f|$表示函数$f$的程序依赖图中的节点个数，$|m(f)|$表示移动应用$A$和$B$间匹配的节点个数。颜克文\cite{yan2014graph}也对程序类之间的依赖关系构建程序依赖图，利用类与类之间的互相调用关系，从而得到移动应用的特征向量。虽然使用程序依赖图能够更细粒度地表征移动应用的功能特征，但是该方法在代码混淆后的移动应用程序中应用受限，可能无法构建有效的程序依赖图。此外，如果对每个移动应用中的每个函数进行程序依赖图构建，将消耗大量存储和计算资源，难以扩展和高效计算。本文对移动应用视图的分析，只需提取视图元素所对应的调用函数，且调用函数通常为Android系统调用函数，在代码混淆中通常保持不变，因此能够有效应对代码混淆问题，且可以更加快速地计算移动应用间的相似性。



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%---------------------------------------     本章小结     ----------------------------------------%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\section{本章小结}
本章对本文相关的研究工作进行调研，分别从函数与程序库推荐、相似移动应用检测两个方面对现有的相关文献和工作进行分析和讨论。由于本文研究的问题——为开发者推荐合适的第三方库——鲜有相应工作，因此本章对与本文相近的工作进行调研分析。

函数和程序库推荐与本文研究问题相近，其主要目的是在项目工程开发过程，为开发者推荐合适、正确的函数、参数等，以避免错误使用和程序漏洞。相关的程序库推荐主要面向的是传统项目工程（如Java、C\#等），且通过分析项目中已使用的程序库情况，为开发者推荐其他相关的程序库。而本文研究的对象是移动应用，且关注分别在需求分析和后期维护两个阶段对开发者需求进行分析，从而为开发者推荐最合适最优的第三方库。本文研究的场景更广，且主要面向移动应用开发者。

相似移动应用检测是本文研究算法中的重要组成部分，因此本章调研了相关工作，并与本文提出的相似性计算方法进行比较和讨论。在相似移动应用检测工作中，主要分为两类方法，分别是动态检测和静态检测。由于动态检测方法需要在运行环境下对移动应用进行检测，因此需要消耗大量的计算资源，难以在大规模的移动应用数据库上进行扩展和应用。静态检测方法通常从移动应用元数据和程序代码两个角度进行分析检测。移动应用元数据包含多种数据类型，能够表征移动应用的功能特征，特别是描述文本，其通常阐述了与移动应用功能相关的文字信息。但此类方法忽略了移动应用代码层信息，特征涵盖不全，因此在相似性计算中可能有偏差。程度代码则从底层、更细粒度的角度体现了移动应用的功能信息，通过分析程序中各函数间的依赖关系，能够提取移动应用在代码层面的特征。但在程序依赖图构建过程中，需要消耗大量计算资源，无法实现快速高效识别。

现有的方法，多仅从元数据或程序代码角度对移动应用进行相似性分析，鲜有同时从本文和视图两个角度对移动应用进行特征提取，因此本文将在第四章中给出本文提出的基于文本和视图的移动应用相似性计算，从而为开发者推荐合适优质的第三方库。




	